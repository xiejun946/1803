ls -lc filename         列出文件的 ctime     chmod时间
ls -lu filename         列出文件的 atime      access时间
ls -l filename          列出文件的 mtime     修改时间
git  reflog  --relative-date  显示git操作记录和时间
git reset --hard HEAD^        回退到上个版本
$ git reset --hard commit_id    退到/进到 指定commit_id
https://opsx.alibaba.com/mirror
epel
##epel 配置方法

###1、备份(如有配置其他epel源)

mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup
mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup
2、下载新repo 到/etc/yum.repos.d/
epel(RHEL 7)

	wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
epel(RHEL 6)

	wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo
epel(RHEL 5)

	wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-5.repo


rz -be 可以解决上传中断的问题，如果单独用rz ，文件比较大的时候回出现失败
泛解析和特定解析的优先级问题
有限匹配特定解析，如特定解析匹配不成功，再匹配泛解析



awk求和公式
awk 'BEGIN{total=0}{total+=$2}END{print total}' 1.txt


redis 查询内存cpu
info 
指定内存
info Memory


vim小技巧
文本搜索与替换
/xx 在文本中从前往后搜索
？xx 在文本中从后往前搜索
光标放在某单词上，*    从前往后搜索该单词
光标放在某单词在，#    从后往前搜索该单词
dd命令删除行，会把删除的数据保存在内存区，可以通过p复制出来，达到的效果就是这一行与下一行交换了
~可以交换光标所在字母的大小写，配置视图模式非常好用
.,$s/vivian/sky/g    将当前行开始匹配的所有vivian 替换为sky
set autoindent
设置制表符为4个空格
set softtabstop=4设置自动缩进

反墙服务器，
国内购买一台fikker服务器，做跳转到真实国外域名

git checkout -b 远程分支以后
ansible bybywxzf -m shell -a "cd /home/git/bywx/gcapi;sudo git branch --set-upstream-to=origin/master remotes/origin/master"
需要
需要关联
需要关联远程分支 这样才能不用指定 Git pull之类命令后的分支
sudo git merge dev
将dev 分支合并到当前分支
git checkout dev
切换分支到dev分支
如果第一次切换
git checkout -b dev 创建并且切换分支
分支切换合并只是改变指针的位置
合并分支之后可以删除之前的dev分支，这样就只有一个分支了


[ctrl]+z 將前台任务丟到后台中暂停
jobs 查看后台的工作状态
fg %jobnumber 将后台的任务拿到前台来处理
bg %jobnumber 将任务放到后台中去处理
kill 管理后台的任务


WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。

WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。



ansible管理云主机
添加秘钥的时候
/home/centos/.ssh/authorized_keys
将管理主机的这个文件复制到被管理主机上，就可以正常管理
ssh原理
自己主机生成公钥私钥，公钥发送给对方机器，并且讲公钥发送到authorized_keys
auth这个文件才是免秘钥登录的关键
一、known_hsots 
ssh会把你每个你访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。我在上面列出的情况，就是这种情况。

原因：一台主机上有多个Linux系统，会经常切换，那么这些系统使用同一ip，登录过一次后就会把ssh信息记录在本地的~/.ssh/known_hsots文件中，切换该系统后再用ssh访问这台主机就会出现冲突警告，需要手动删除修改known_hsots里面的内容。

有以下两个解决方案： 
1. 手动删除修改known_hsots里面的内容； 
2. 修改配置文件“~/.ssh/config”，加上这两行，重启服务器。 
StrictHostKeyChecking no 
UserKnownHostsFile /dev/null

优缺点： 
1. 需要每次手动删除文件内容，一些自动化脚本的无法运行（在SSH登陆时失败），但是安全性高； 
2. SSH登陆时会忽略known_hsots的访问，但是安全性低；

二、authorized_keys 
1、就是为了让两个linux机器之间使用ssh不需要用户名和密码。采用了数字签名RSA或者DSA来完成这个操作

2、模型分析

假设 A （192.168.20.59）为客户机器，B（192.168.20.60）为目标机；

要达到的目的： 
A机器ssh登录B机器无需输入密码； 
加密方式选 rsa|dsa均可以，默认dsa 
单向登陆的操作过程（能满足上边的目的）： 
1、登录A机器 
2、ssh-keygen -t [rsa|dsa]，将会生成密钥文件和私钥文件 id_rsa,id_rsa.pub或id_dsa,id_dsa.pub 
3、将 .pub 文件复制到B机器的 .ssh 目录， 并 cat id_dsa.pub >> ~/.ssh/authorized_keys 
4、大功告成，从A机器登录B机器的目标账户，不再需要密码了；（直接运行 #ssh 192.168.20.60 ）

双向登陆的操作过程：

1、ssh-keygen做密码验证可以使在向对方机器上ssh ,scp不用使用密码.具体方法如下: 
2、两个节点都执行操作：#ssh-keygen -t rsa 
然后全部回车,采用默认值.

3、这样生成了一对密钥，存放在用户目录的~/.ssh下。 
将公钥考到对方机器的用户目录下，并将其复制到~/.ssh/authorized_keys中（操作命令：#cat id_dsa.pub >> ~/.ssh/authorized_keys）



epel
安装epel的rpm安装包之后会自动生成epel的yum源，epel是第三项扩展yum源

salt
这些模块是python写成的文件，里面会有好多函数，如cmd.run，当我们执行salt '*' cmd.run 'uptime'的时候，master下发任务匹配到的minion上去，minion执行模块函数，并返回结果。master监听4505和4506端口，4505对应的是ZMQ的PUB system，用来发送消息，4506对应的是REP system是来接受消息的。

具体步骤如下

Salt stack的Master与Minion之间通过ZeroMq进行消息传递，使用了ZeroMq的发布-订阅模式，连接方式包括tcp，ipc

salt命令，将cmd.run ls命令从salt.client.LocalClient.cmd_cli发布到master，获取一个Jodid，根据jobid获取命令执行结果。

master接收到命令后，将要执行的命令发送给客户端minion。

minion从消息总线上接收到要处理的命令，交给minion._handle_aes处理

minion._handle_aes发起一个本地线程调用cmdmod执行ls命令。线程执行完ls后，调用minion._return_pub方法，将执行结果通过消息总线返回给master

master接收到客户端返回的结果，调用master._handle_aes方法，将结果写的文件中

salt.client.LocalClient.cmd_cli通过轮询获取Job执行结果，将结果输出到终端


http403报错，有可能是域名备案问题，大陆的服务器web服务需要备案，香港的可以不用备案


vmware网卡配置
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp/static  IPADDR=XXX.XXX.XXX.XXX
DEFROUTE=yes
GATEWAY=192.168.0.1
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=f1811dd3-3d19-432f-b8cf-4c588077b2a4
DEVICE=ens33
ONBOOT=yes


配置以后重启network


java环境变量设置

windows下

装JDK 选择安装目录 安装过程中会出现两次 安装提示 。第一次是安装 jdk ，第二次是安装 jre 。建议两个都安装在同一个java文件夹中的不同文件夹中。（不能都安装在java文件夹的根目录下，jdk和jre安装在同一文件夹会出错）?

1：安装jdk 随意选择目录 只需把默认安装目录 \java 之前的目录修改即可
2：安装jre→更改→ \java 之前目录和安装 jdk 目录相同即可
注：若无安装目录要求，可全默认设置。无需做任何修改，两次均直接点下一步。

安装完JDK后配置环境变量 计算机→属性→高级系统设置→高级→环境变量

系统变量→新建 JAVA_HOME 变量 。
变量值填写jdk的安装目录（本人是 E:\Java\jdk1.7.0)

系统变量→寻找 Path 变量→编辑
在变量值最后输入 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;
（注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码）
系统变量→新建 CLASSPATH 变量
变量值填写  .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar（注意最前面有一点）
系统变量配置完毕

检验是否配置成功 运行cmd 输入 java -version （java 和 -version 之间有空格）
若如图所示 显示版本信息 则说明安装和配置成功。
  
  
linux环境下


修改/etc/profile文件 

如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。 
·用文本编辑器打开/etc/profile 
·在profile文件末尾加入： 
export JAVA_HOME=/usr/share/jdk1.6.0_14 
export PATH=$JAVA_HOME/bin:$PATH 
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 


使用yum安装的tomcat，其安装目录在/etc下，webapps在/var/lib/tomcat/webapps
可以直接拖war包或者新建目录使用静态文件




jenkins
/var/cache/jenkins  缓存目录
/var/lib/jenkins 家目录
/var/log/jenkins 日志目录
 3个目录都需要给deploy权限



openssl制作本地证书

yum -y install openssh-server openssh-clients
mdkik -p /etc/gitlab/ssl
openssl genrsa -out "/etc/gitlab/ssl/gitlab.example.com.key" 2048
openssl req -new -key "/etc/gitlab/ssl/gitlab.example.com.key" -out "/etc/gitlab/ssl/gitlab.example.com.csr"
openssl x509 -req -days 365 -in "/etc/gitlab/ssl/gitlab.example.com.csr" -signkey "/etc/gitlab/ssl/gitlab.example.com.key" -out "/etc/gitlab/ssl/gitlab.example.com.crt"
oepnssl dhparam -out /etc/gitlab/ssl/dhparams.pem 2048
chmod 600 *


pipeline脚本语法


#!groovy

pipeline {
    agent {node {label 'master'}}    定义在哪里构建

    environment {       定义环境
        PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin"
    }

    parameters {   参数
        choice(   选项参数
            choices: 'dev\nprod',
            description: 'choose deploy environment',
            name: 'deploy_env'
            )
        string (name: 'version', defaultValue: '1.0.0', description: 'build version')   文件参数
    }

    stages {   构建
        stage("Checkout test repo") {   构建1
            steps{
                sh 'git config --global http.sslVerify false'
                dir ("${env.WORKSPACE}") {   定义git仓库以root用户登录
                    git branch: 'master', credentialsId:"9aa11671-aab9-47c7-a5e1-a4be146bd587", url: 'https://root@gitlab.example.com/root/test-repo.git'
                }
            }
        }
        stage("Print env variable") {   构建2
            steps {
                dir ("${env.WORKSPACE}") {
                    sh """
                    echo "[INFO] Print env variable"
                    echo "Current deployment environment is $deploy_env" >> test.properties
                    echo "The build is $version" >> test.properties
                    echo "[INFO] Done..."
                    """
                }
            }
        }
        stage("Check test properties") {   构建3
            steps{
                dir ("${env.WORKSPACE}") {   定义工作目录
                    sh """    使用shell命令
                    echo "[INFO] Check test properties"
                    if [ -s test.properties ]
                    then 
                        cat test.properties
                        echo "[INFO] Done..."
                    else
                        echo "test.properties is empty"
                    fi
                    """

                    echo "[INFO] Build finished..."
                }
            }
        }
    }
}





